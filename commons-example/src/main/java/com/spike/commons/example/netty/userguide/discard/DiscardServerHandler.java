package com.spike.commons.example.netty.userguide.discard;

import org.apache.log4j.Logger;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.util.CharsetUtil;
import io.netty.util.ReferenceCountUtil;

/**
 * <pre>
 *  DiscardServer handler
 *  responsibility: handle IO events generated by Netty
 * 
 * 处理Netty产生的事件
 * </pre>
 * @see DiscardServer
 * @see ChannelInboundHandlerAdapter
 */
public class DiscardServerHandler extends ChannelInboundHandlerAdapter {

  private static final Logger LOG = Logger.getLogger(DiscardServerHandler.class);

  /**
   * <pre>
   * occurs when new data is received from a client
   * 接收到客户端消息时触发，消息的类型是{@link ByteBuf}
   * 
   * </pre>
   */
  @Override
  public void channelRead(ChannelHandlerContext context, Object message) {
    // do nothing to the incoming message: discard

    // it's handler's responsibility to release reference-counted object
    // passed to it
    // ((ByteBuf) message).release();

    // renderer the incoming message
    ByteBuf bb = (ByteBuf) message;
    try {

      // while (bb.isReadable()) {
      // System.out.print((char) bb.readByte());
      // System.out.flush();
      // }

      // or use
      System.err.println(bb.toString(CharsetUtil.UTF_8));

    } finally {
      // ByteBuf是引用计数对象
      // handler的职责包括显式传递给它的引用计数对象
      ReferenceCountUtil.release(message);
    }

  }

  /**
   * <pre>
   * occurs when exception raised by Netty due to IO error, or
   * due to handler's operation when processing events
   * 
   * 在Netty抛出IO异常或者handler处理事件操作中抛出异常时触发
   * 
   * </pre>
   */
  @Override
  public void exceptionCaught(ChannelHandlerContext context, Throwable cause) {
    // 记录日志
    if (cause != null) {
      // cause.printStackTrace();
      LOG.error(cause);
    }

    // 关闭channel
    LOG.info("关闭链接...");
    context.close();

    // 其他处理方式：根据异常类型处理，在关闭连接前发送响应消息等
  }
}
